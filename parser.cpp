#include <deque>
#include "parser.hpp"

// LR Automaton without error recovery.
//
//      state == (RULE[BASE[state] + c] & 0xff)
//      and (ctrl == RULE[BASE[state] + c] >> 8
//        and (ctrl == 0xff then accept
//          or ctrl < 0x80 then shift ctrl
//          or ctrl >= 0x80 then goto 0xfe - ctrl))

// prod ctrl  production
// ----------------------------------------------------------------
//    0   fe  prog: expr ";;"
//    1   fd  prog: "let" ID "=" expr ";;"
//    2   fc  prog: "let" "rec" ID "=" expr ";;"
//    3   fb  expr: "let" ID "=" expr "in" expr
//    4   fa  expr: "let" "rec" ID "=" expr "in" expr
//    5   f9  expr: "if" expr "then" expr "else" expr
//    6   f8  expr: "fun" ID "->" expr
//    7   f7  expr: pexpr
//    8   f6  expr: pexpr "<" pexpr
//    9   f5  pexpr: pexpr "+" mexpr
//   10   f4  pexpr: mexpr
//   11   f3  mexpr: mexpr "*" app
//   12   f2  mexpr: app
//   13   f1  app: app aexpr
//   14   f0  app: aexpr
//   15   ef  aexpr: ID
//   16   ee  aexpr: INTV
//   17   ed  aexpr: BOOL
//   18   ec  aexpr: "(" expr ")"

static void
reduce_callback (int prod, parser_callback_base& cb)
{
    switch (prod) {
    case 0:
        cb.prog_expr ();
        break;
    case 1:
        cb.prog_let ();
        break;
    case 2:
        cb.prog_let_rec ();
        break;
    case 3:
        cb.expr_let ();
        break;
    case 4:
        cb.expr_let_rec ();
        break;
    case 5:
        cb.expr_if ();
        break;
    case 6:
        cb.expr_fun ();
        break;
    case 7:
        cb.expr_pexpr ();
        break;
    case 8:
        cb.expr_pexpr_lt_pexpr ();
        break;
    case 9:
        cb.pexpr_pexpr_plus_mexpr ();
        break;
    case 10:
        cb.pexpr_mexpr ();
        break;
    case 11:
        cb.mexpr_mexpr_times_app ();
        break;
    case 12:
        cb.mexpr_app ();
        break;
    case 13:
        cb.app_app_aexpr ();
        break;
    case 14:
        cb.app_aexpr ();
        break;
    case 15:
        cb.aexpr_id ();
        break;
    case 16:
        cb.aexpr_intv ();
        break;
    case 17:
        cb.aexpr_bool ();
        break;
    case 18:
        cb.aexpr_lparen_expr_rparen ();
    }
}

static const unsigned short PRODUCTION[] = {
    0x1802, 0x1805, 0x1806, 0x1706, 0x1707, 0x1706, 0x1704, 0x1701,
    0x1703, 0x1603, 0x1601, 0x1503, 0x1501, 0x1402, 0x1401, 0x1301,
    0x1301, 0x1301, 0x1303,
};
static const short BASE[] = {
    0, -12, 13, 13, 4, 8, 1, 31, 38, 46, 65, 83, 101, 119, 126, 17, 9, 40,
    53, 63, 47, 135, 143, 77, 164, 53, 171, 50, 183, 51, 60, 195, 109, 218,
    226, 245, 75, 252, 75, 264, 119, 128, 173, 276, 173, 288, 174, 300, 234,
    177, 312, 253, 176, 335
};
static const unsigned short RULE[] = {
    0x0401, 0x0501, 0x0601, 0x0b01, 0x0c01, 0x0d01, 0x0e01, 0x0a01,
    0x0901, 0x0801, 0x0701, 0x0301, 0x0201, 0xff02, 0x0f03, 0x1104,
    0x1406, 0xfe0f, 0x1a10, 0x1004, 0x1305, 0x0505, 0x0605, 0x0b05,
    0x0c05, 0x0d05, 0x0e05, 0x0a05, 0x0905, 0x0805, 0x0705, 0x1205,
    0xf707, 0xf707, 0xf707, 0xf707, 0xf707, 0x1607, 0x1507, 0xf408,
    0xf408, 0xf408, 0xf408, 0xf408, 0xf408, 0xf408, 0x1708, 0xf209,
    0xf209, 0xf209, 0xf209, 0xf209, 0xf209, 0xf209, 0xf209, 0x1b11,
    0x1c12, 0x1f14, 0x2319, 0x251b, 0x271d, 0x0b09, 0x0c09, 0x0d09,
    0x0e09, 0x1809, 0xf00a, 0xf00a, 0xf00a, 0xf00a, 0xf00a, 0xf00a,
    0xf00a, 0xf00a, 0x1e13, 0x281e, 0x2a24, 0x2b24, 0x1d13, 0x2d26,
    0xf00a, 0xf00a, 0xf00a, 0xf00a, 0xef0b, 0xef0b, 0xef0b, 0xef0b,
    0xef0b, 0xef0b, 0xef0b, 0xef0b, 0x0b17, 0x0c17, 0x0d17, 0x0e17,
    0x0a17, 0x2217, 0xef0b, 0xef0b, 0xef0b, 0xef0b, 0xee0c, 0xee0c,
    0xee0c, 0xee0c, 0xee0c, 0xee0c, 0xee0c, 0xee0c, 0xf620, 0xf620,
    0xf620, 0xf620, 0xf620, 0x1620, 0xee0c, 0xee0c, 0xee0c, 0xee0c,
    0xed0d, 0xed0d, 0xed0d, 0xed0d, 0xed0d, 0xed0d, 0xed0d, 0xed0d,
    0x2f28, 0xf829, 0xf829, 0xf829, 0xf829, 0xf829, 0xed0d, 0xed0d,
    0xed0d, 0xed0d, 0x130e, 0x050e, 0x060e, 0x0b0e, 0x0c0e, 0x0d0e,
    0x0e0e, 0x0a0e, 0x090e, 0x080e, 0x070e, 0x190e, 0x0b15, 0x0c15,
    0x0d15, 0x0e15, 0x0a15, 0x0915, 0x0815, 0x2015, 0x0b16, 0x0c16,
    0x0d16, 0x0e16, 0x0a16, 0x0916, 0x2116, 0xf118, 0xf118, 0xf118,
    0xf118, 0xf118, 0xf118, 0xf118, 0xf118, 0xfd2a, 0x312c, 0x322c,
    0x2b2e, 0xfc31, 0x3234, 0xf118, 0xf118, 0xf118, 0xf118, 0x131a,
    0x051a, 0x061a, 0x0b1a, 0x0c1a, 0x0d1a, 0x0e1a, 0x0a1a, 0x091a,
    0x081a, 0x071a, 0x241a, 0x131c, 0x051c, 0x061c, 0x0b1c, 0x0c1c,
    0x0d1c, 0x0e1c, 0x0a1c, 0x091c, 0x081c, 0x071c, 0x261c, 0x131f,
    0x051f, 0x061f, 0x0b1f, 0x0c1f, 0x0d1f, 0x0e1f, 0x0a1f, 0x091f,
    0x081f, 0x071f, 0x291f, 0xf521, 0xf521, 0xf521, 0xf521, 0xf521,
    0xf521, 0xf521, 0x1721, 0xf322, 0xf322, 0xf322, 0xf322, 0xf322,
    0xf322, 0xf322, 0xf322, 0xfb30, 0xfb30, 0xfb30, 0xfb30, 0xfb30,
    000000, 0x0b22, 0x0c22, 0x0d22, 0x0e22, 0x1822, 0xec23, 0xec23,
    0xec23, 0xec23, 0xec23, 0xec23, 0xec23, 0xec23, 0xf933, 0xf933,
    0xf933, 0xf933, 0xf933, 000000, 0xec23, 0xec23, 0xec23, 0xec23,
    0x1325, 0x0525, 0x0625, 0x0b25, 0x0c25, 0x0d25, 0x0e25, 0x0a25,
    0x0925, 0x0825, 0x0725, 0x2c25, 0x1327, 0x0527, 0x0627, 0x0b27,
    0x0c27, 0x0d27, 0x0e27, 0x0a27, 0x0927, 0x0827, 0x0727, 0x2e27,
    0x132b, 0x052b, 0x062b, 0x0b2b, 0x0c2b, 0x0d2b, 0x0e2b, 0x0a2b,
    0x092b, 0x082b, 0x072b, 0x302b, 0x132d, 0x052d, 0x062d, 0x0b2d,
    0x0c2d, 0x0d2d, 0x0e2d, 0x0a2d, 0x092d, 0x082d, 0x072d, 0x332d,
    0x132f, 0x052f, 0x062f, 0x0b2f, 0x0c2f, 0x0d2f, 0x0e2f, 0x0a2f,
    0x092f, 0x082f, 0x072f, 0x342f, 0x1332, 0x0532, 0x0632, 0x0b32,
    0x0c32, 0x0d32, 0x0e32, 0x0a32, 0x0932, 0x0832, 0x0732, 0x3532,
    0xfa35, 0xfa35, 0xfa35, 0xfa35, 0xfa35,
};

bool
parse (std::istream& cin, scanner_type& token, parser_callback_base& cb)
{
    const int ncheck = sizeof (RULE) / sizeof (RULE[0]);
    if (! token.next (cin)) {
        return false;
    }
    std::deque<int> kont {1};
    for (;;) {
        int const state = kont.back ();
        int const kind = token.kind ();
        int const i = BASE[state] + kind;
        if (i < 0 || ncheck <= i || state != (RULE[i] & 0xff)) {
            break;
        }
        int const ctrl = RULE[i] >> 8;
        if (0xff == ctrl) {
            return true;
        }
        else if (ctrl < 0x80) {
            cb.shift (kind, token.value ());
            kont.push_back (ctrl);
            if (! token.next (cin)) {
                break;
            }
        }
        else {
            int const prod = 0xfe - ctrl;
            reduce_callback (prod, cb);
            for (int i = PRODUCTION[prod] & 0xff; i > 0; --i) {
                kont.pop_back ();
            }
            int const state1 = kont.back ();
            int const j = BASE[state1] + (PRODUCTION[prod] >> 8);
            if (j < 0 || ncheck <= j || state1 != (RULE[j] & 0xff)) {
                break;
            }
            kont.push_back (RULE[j] >> 8);
        }
    }
    return false;
}
